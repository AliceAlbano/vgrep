#!/usr/bin/env python2

"""
This module is a reimpementation of the ancient cgvg perl scripts.

Visit https://github.com/vrothberg/vgrep for more information.
"""

# (c) 2015 Valentin Rothberg <valentinrothberg@gmail.com>
#
# Licensed under the terms of the GNU GPL License version 3

# Ignore some annoying pylint warnings
# pylint: disable=W0613
# pylint: disable=W0141

import argparse
import os
import sys
import pickle
import re
import signal

from array import array
from pipes import quote
from subprocess import Popen, PIPE, STDOUT


HOMEDIR = os.getenv("HOME")
CACHE = HOMEDIR + "/.cache/vgrep"
EDITOR = os.getenv("EDITOR", "vim")

ANSI_REG = re.compile(r'\x1B\[[0-9;]*[ABCDEFGHJKSTfmnsulh]')


def parse_options():
    """
    User interface of this module.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--show', dest='show', action='store',
                        default=False, nargs='?',
                        help="show indexed location in the system's editor")
    parser.add_argument('--no-git', dest='nogit', action='store_true',
                        default=False,
                        help="use 'grep' instead of 'git grep'")
    parser.add_argument('--no-git-submodules', dest='nogitsubmodules',
                        action='store_true', default=False,
                        help="do not search in git submodules")
    parser.add_argument('--no-less', dest='noless', action='store_true',
                        default=False,
                        help="print to stdout instead of using less")
    parser.add_argument('--no-header', dest='noheader', action='store_true',
                        default=False,
                        help="do not print the pretty header at the top of "
                             "the results")
    args, gitargs = parser.parse_known_args()
    return args, gitargs


def parse_line(sloc):
    """
    Returns indices of first and second delimiter of the input line.
    Delimiters are `\0', `:', `-'.

    One or both indices can be -1.
    """

    lfile = sloc.find('\0')
    if lfile == -1:
        lfile = sloc.find(':')
    lline = sloc.find('\0', lfile+1)
    if lline == -1 or not sloc[lfile+1:lline].isdigit():
        lline = sloc.find(':', lfile+1)
    if lline == -1 or not sloc[lfile+1:lline].isdigit():
        lline = sloc.find('-', lfile+1)

    return lfile, lline


def main():
    """
    Main routine of this module.
    """
    args, gitargs = parse_options()

    if gitargs:
        gitargs = ["'%s'" % x for x in gitargs]  # needed to pass args to grep
        grep_args = " ".join(gitargs)

        slocs = grep(grep_args, args.nogit, args.nogitsubmodules)
        slocs = filter(None, slocs)  # filter empty hits
        if not slocs:
            # dump and exit if there is not hit
            dump(slocs)
            sys.exit(0)

        # test ouput format of grep
        test = rem_ansi(slocs[0])
        if not re.match(r"^[^:\0]+[:\0]\d+[\0:-].*$", test):
            sys.stderr.write("Wrong format from (git) grep: '%s'\n" % test)
            sys.stderr.write("vgrep expects the format '%s:%s:%s' or '%s\\0%s\\0%s'\n"
                             % (blu('file'), green('line'), 'content',
                                blu('file'), green('line'), 'content'))
            sys.exit(1)

        dump(slocs)

    else:
        slocs = load()
        if not slocs:
            sys.exit("Could not load cached data")
        cwd = rem_ansi(slocs.pop(0))
        if cwd != os.getcwd():
            sys.exit("Change directory to %s to show locations" % cwd)
        if slocs is None:
            sys.exit("Please grep for a symbol first")

    if (gitargs and args.show is None) or args.show is False:
        try:
            print_slocs(slocs, args.noless, args.noheader)
        except IOError:
            pass

    ret = None
    # -s given but no show string given
    if args.show is None:
        show_help = True
        while True:
            try:
                show_expr = ask_show_expr(show_help)
            except EOFError:
                break
            show_help = False
            dispatch_show_expr(show_expr, slocs, args)
    elif args.show:
        ret = dispatch_show_expr(args.show, slocs, args)

    if ret == error:
        sys.exit(-1)


def ask_show_expr(verbose=False):
    """
    Prompts the user for a show expression. If verbose is given, a short help is
    printed beforehand.
    """
    if verbose:
        print "help: <Selector><Cmd>"
        print "      Selector: ",       \
            yel("`3'"), "(one)",        \
            yel("`5,23'"), "(mult.)",   \
            yel("`7-10'"), "(range)",   \
            yel("`/ker.el/'"), "(regex)"
        print "      Cmd: ",            \
            yel("p") + "rint,",         \
            yel("s") + "how,",          \
            yel("c") + "ontext,",       \
            yel("f") + "iles,",         \
            "e" + yel("x") + "ecute,",  \
            yel("q") + "uit,"
        print '      E.g.: 40,45s -- show matches 40 and 45 in $EDITOR'

    return raw_input(green("What do you want to see?> "))


def dispatch_show_expr(show_expr, slocs, options):
    """
    Parses and executes a show expression.
    """
    try:
        indices, cmd, cmd_arg = parse_show(show_expr, slocs)
    except (ValueError, IndexError, AssertionError) as ex:
        return error("parse error: " + str(ex))

    options.show_cmds = {
        's': show_cmd_open,
        'p': show_cmd_print,
        'P': show_cmd_print_and_save,
        'c': show_cmd_context,
        'x': show_cmd_execute,
        'f': show_cmd_files,
        'q': show_cmd_quit,
        'h': show_cmd_help,
        'g': show_cmd_grep,
    }
    if cmd not in options.show_cmds:
        return error("Command not implemented: %s" % cmd)
    return options.show_cmds[cmd](slocs, indices, cmd_arg, options)


################################################################
# Utility Functions
################################################################

def yel(string, light=1):
    """
    Color %string.
    """
    if light:
        return "\033[93m%s\033[0m" % string
    return "\033[33m%s\033[0m" % string


def green(string, light=1):
    """
    Color %string.
    """
    if light:
        return "\033[92m%s\033[0m" % string
    return "\033[32m%s\033[0m" % string


def blu(string, light=1):
    """
    Color %string.
    """
    if light:
        return "\033[94m%s\033[0m" % string
    return "\033[34m%s\033[0m" % string


def und(string):
    """
    Underline %string.
    """
    return "\033[4m%s\033[0m" % string


def warning(msg):
    """
    Prints a warning to the terminal.
    """
    print yel("Warning:", True), msg
    return warning


def error(msg):
    """
    Prints an error message.
    """
    print msg
    return error


def rem_ansi(string):
    """
    Remove ANSI codes from string.
    """
    return ANSI_REG.sub('', string)


################################################################
# Parse Input Functions
################################################################

def parse_show(show, slocs):
    """
    Parses a show expression. Returns the matched indices (as a list of indices
    into the slocs array, the show command, and the command arguments as a
    string.
    """
    match = re.match("^([0-9, :-]*|/[^/]*/)([ghqspPfcx].*)?$", show)
    assert match, "invalid show expression: " + show
    if match.groups()[1] is None:
        cmd = 's'
        args = ''
    elif match.group(2):
        cmd = match.group(2)[0]
        args = match.group(2)[1:]
    else:
        assert not match.group(3), "invalid show expression: " + show

    indices = []
    # If range is '', select all
    if not match.group(1):
        return range(0, len(slocs)), cmd, args
    # Parse regex
    if match.group(1).startswith("/"):
        regex = re.compile(match.group(1)[1:-1])
        for idx, line in enumerate(slocs):
            if re.search(regex, line):
                indices.append(idx)
        return indices, cmd, args

    # parse literal range expressions
    for subrange in filter(None, re.split("[ ,]", match.group(1))):
        if '-' in subrange or ':' in subrange:
            if ':' in subrange:
                start, end = subrange.split(':', 1)
            else:
                start, end = subrange.split('-', 1)
            if not start:
                start = "0"
            if not end:
                end = str(len(slocs)-1)
            indices.extend(range(int(start), int(end) + 1))
        else:
            indices.append(int(subrange))
    assert all([x < len(slocs) for x in indices]), "range item too large"
    return indices, cmd, args


################################################################
# Show Commands
################################################################

def show_cmd_quit(slocs, indices, cmd_arg, option):
    """
    Quits the interactive mode.
    """
    sys.exit(0)


def show_cmd_help(slocs, indices, cmd_arg, options):
    """
    Gives help and advice. This command is like a good friend.

    cmd_arg: command name or command identifier

    Commands:
        {commands}

    Examples:
        h p       -- help for the print command
        h execute -- the execute command
    """
    # Replace {commands} by the command list
    if "{commands}" in show_cmd_help.__doc__:
        commands = []
        for key, val in options.show_cmds.items():
            commands.append("%s -- %s" % (key, val.__name__))
        doc = show_cmd_help \
            .__doc__ .format(commands="\n         ".join(commands))
        show_cmd_help.__doc__ = doc

    cmd = cmd_arg.strip()
    if cmd in options.show_cmds:
        help(options.show_cmds[cmd])
    elif "show_cmd_" + cmd_arg in globals():
        help(globals()["show_cmd_" + cmd_arg])
    elif not cmd:
        help(show_cmd_help)
    else:
        return warning("no help found for: " + cmd)


def show_cmd_open(slocs, indices, cmd_arg, option):
    """
    Opens $EDITOR for every match.

    This command opens the program, given by the $EDITOR environment variable,
    for every selected match at the given line.
    """
    if len(indices) > 3:
        inp = raw_input("Matched %s lines: visit all of them? (N/y) "
                        % len(indices))
        if not ("y" in inp or 'Y' in inp):
            return
    for idx in indices:
        sloc = rem_ansi(slocs[idx])
        lfile, lline = parse_line(sloc)
        if lfile == -1 or lline == -1:
            return error("Please specify a valid index")
        cmd = "%s +%s %s" % (EDITOR, sloc[lfile+1:lline], sloc[:lfile])
        pop = Popen(cmd, shell=True)
        pop.wait()


def show_cmd_print(slocs, indices, cmd_arg, options):
    """
    Prints all matched lines.
    """
    try:
        print_slocs(slocs, options.noless, options.noheader, set(indices))
    except IOError as err:
        return error("print command failed: " + str(err))


def show_cmd_print_and_save(slocs, indices, cmd_arg, options):
    """
    Replaces the match cache by the given selection. The selected matches are
    renumbered and the new match cache is printed.
    """
    match_slocs = []
    for idx in indices:
        match_slocs.append(slocs[idx])
    # Save matched results
    dump(match_slocs)
    # Update the slocs variable
    slocs[:] = match_slocs
    # Output the matched lines (reordered)
    try:
        print_slocs(match_slocs, options.noless, options.noheader)
    except IOError as err:
        return error("print and save command failed: " + str(err))


def show_cmd_context(slocs, indices, cmd_arg, options):
    """
    For every match, this command gives the context of the match within the
    matched file.  The cmd_arg gives the number of context lines. Default is 10
    lines of context.

    Example:
       3-5c2 -- for matches 3 till 5, print 2 lines of context
    """
    try:
        context_lines = int(cmd_arg)
    except ValueError:
        context_lines = 10
    try:
        print_contexts(slocs, indices, context_lines, options)
    except IOError as err:
        return error("context command failed: " + str(err))


def show_cmd_files(slocs, indices, cmd_arg, options):
    """
    Prints the list of matched files.
    """
    files = []
    for idx in indices:
        sloc = rem_ansi(slocs[idx])
        lfile, _ = parse_line(sloc)
        if not sloc[:lfile] in files:
            files.append(sloc[:lfile])
    print '\n'.join(files)


def show_cmd_execute(slocs, indices, cmd_arg, options):
    """
    Execute a command with format strings supplied form match information. When
    multiple matches are selected, a repeating group has to be supplied given.
    When no format characters are given, the filename(s) are simply appended to
    the command.

    Format Strings:
        %f -- filename of the match
        %n -- line number of match
        %m -- matched file content

    Examples:
        1x vim          -- open file of match 1
        2-7x ls -l      -- list matched files
        3x echo %f:%n   -- outout filename and match line for match 3
        2-7x echo {%n } -- print matched line numbers
    """
    format_strings = {
        '%f': '{filename}',
        '%n': '{line}',
        '%m': '{match}'
    }
    if not any((x in cmd_arg) for x in format_strings):
        if len(indices) == 1:
            cmd_arg += " %f"
        else:
            cmd_arg += '{ "%f"}'
    start = cmd_arg.find("{")
    if start != -1:
        end = cmd_arg.find("}", start)
    if start == -1 or end == -1:
        start, end = 0, len(cmd_arg)+1
        cmd_arg = "{" + cmd_arg + "}"
        if len(indices) != 1:
            return error("When having multiple matches selected, "
                         "use {..%f..%n} to repeat")
    cmd = []
    cmd_fmt = cmd_arg[start+1:end]
    for f, t in format_strings.items():
        cmd_fmt = cmd_fmt.replace(f, t)
    for idx in indices:
        sloc = rem_ansi(slocs[idx])
        lfile, lline = parse_line(sloc)
        if lfile != -1 and lline != -1:
            cmd.append(cmd_fmt.format(filename=sloc[:lfile],
                                      line=sloc[lfile+1:lline],
                                      match=sloc[lline+1:]))
    cmd = cmd_arg[:start] + "".join(cmd) + cmd_arg[end+1:]
    pop = Popen(cmd, shell=True)
    pop.wait()


def show_cmd_grep(slocs, indices, cmd_arg, options):
    """
    Executes grep for a pattern on the matched files.
    """
    files = []
    for idx in indices:
        sloc = rem_ansi(slocs[idx])
        lfile, _ = parse_line(sloc)
        if not sloc[:lfile] in files:
            files.append(sloc[:lfile])

    try:
        grep_slocs = grep("-H " + quote(cmd_arg.strip()), True, False, files)
    except IOError as err:
        return error("grep failed: " + str(err))
    grep_slocs = filter(None, grep_slocs)

    try:
        print_slocs(grep_slocs, options.noless, options.noheader)
    except IOError as err:
        return error("print command failed: " + str(err))

    inp = raw_input(green("Update match cache? (N/y) "))
    if not ("y" in inp or 'Y' in inp):
        return
    dump(grep_slocs)
    slocs[:] = grep_slocs


################################################################
# Backend Input/Output Functions
################################################################

def print_slocs(slocs, noless, noheader, indices=None):
    """
    Print SLOCS on terminal.
    """
    max_indx = len(str(len(slocs)))
    max_file = 0
    max_line = 0

    lengths = array('i', [])

    pline = parse_line  # makes it faster by avoiding function lookups
    for i in range(0, len(slocs)):
        if indices is not None and i not in indices:
            lengths.append(-1)
            lengths.append(-1)
            continue
        sloc = rem_ansi(slocs[i])
        lfile, lline = pline(sloc)
        lengths.append(lfile)
        lengths.append(lline)
        if lfile > max_file:
            max_file = lfile
        if (lline-lfile) > max_line:
            max_line = (lline-lfile)

    fdc = sys.stdout
    pop = None
    if noless is False:
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        pop = Popen("less -FRXS", shell=True, stdin=PIPE)
        fdc = pop.stdin

    if noheader is False:
        if len("Index") > max_indx:
            max_indx = len("Index")
        if len("File") > max_file:
            max_file = len("File")
        if len("Line") > max_line:
            max_line = len("Line")

        fdc.write(und(yel('{0:>{1}}'.format("Index", max_indx))) + " ")
        fdc.write(und(blu('{0:<{1}}'.format("File", max_file))) + " ")
        fdc.write(und(green('{0:>{1}}'.format("Line", max_line))) + " ")
        fdc.write(und("Content") + "\n")

    lfile, lline, lcount = 0, 0, 0
    for i in range(0, len(slocs)):
        # If we have an index set, print only those
        if indices is not None and i not in indices:
            continue

        sloc = rem_ansi(slocs[i])
        lfile = lengths[i*2] + 1
        lline = lengths[i*2 + 1] + 1

        if lfile == 0 or lline == 0:
            fdc.write(yel("-" * (max_indx+max_file+max_line+2)) + " " + sloc + "\n")
            continue

        light = lcount % 2
        lcount += 1

        fdc.write(yel('{0:>{1}} '.format(i, max_indx), light))
        fname = sloc[:lfile-1]
        if fname.startswith("./"):
            fname = fname[2:]
        fdc.write(blu('{0:<{1}} '.format(fname, max_file), light))
        fdc.write(green('{0:>{1}} '.format(sloc[lfile:lline-1], max_line), light))
        fdc.write(slocs[i][lline:].lstrip() + "\n")

    fdc.close()
    if noless is False:
        pop.wait()


def execute(cmd):
    """
    Execute %cmd and return stdout.  Exit in case of error.
    """
    pop = Popen(cmd, stdout=PIPE, stderr=STDOUT, shell=True)
    (stdout, _) = pop.communicate()  # wait until finished
    if pop.returncode != 0:
        if stdout != '':
            sys.exit("Command failed: %s\n%s" % (cmd, stdout))
    return stdout


def grep(grep_args, nogit, nogitsubmodules, files=None):
    """
    Search symbol in current Git tree and return the output. If %nogit is set
    grep is called instead of git grep.
    """
    grep_args = "-In --color=always %s" % grep_args

    if nogit is True:
        # overwrite grep colors to only highlight matches
        colors = "GREP_COLORS='ms=01;31:mc=:sl=:cx=:fn=:ln=:bn=:se='"
        if files is None:
            grep_args += " -r ."
        else:
            for filename in files:
                grep_args += " %s" % quote(filename)
        return execute("%s grep -Z %s" % (colors, grep_args)).rsplit("\n")

    colors = "-c 'color.grep.match=red bold'"
    git_grep_cmd = "HOME= git %s grep -z %s" % (colors, grep_args)
    git_grep_results = execute(git_grep_cmd).rsplit("\n")

    # When submodules are ignored, we can return here.
    if nogitsubmodules is True:
        return git_grep_results

    cwd = os.path.abspath(os.path.curdir)
    # Get all submodules (recursive)
    list_cmd = "git submodule --quiet foreach --recursive %s" % \
               quote('echo "$toplevel/$path"')
    submodules = execute(list_cmd).rsplit("\n")
    for submodule in filter(None, submodules):
        # check if submodule is below the current working directory
        submodule = os.path.normpath(submodule)
        if os.path.commonprefix([submodule, cwd]) != cwd:
            continue
        # Get the path relative to the CWD
        submodule = os.path.relpath(submodule, cwd)

        # Start grep within the submodule
        sub_grep_cmd = "cd %s && %s" % (quote(submodule), git_grep_cmd)
        lines = execute(sub_grep_cmd).rsplit("\n")
        # Prepend the relative submodule path to each line
        for line in filter(None, lines):
            git_grep_results.append(os.path.join(submodule, line))

    return git_grep_results


old_child = None


def dump(data):
    """
    Fork and dump %data to the local cache.
    """
    global old_child
    if old_child:
        os.kill(old_child, 15)
        os.waitpid(old_child, 0)

    child = os.fork()
    if child:
        old_child = child
        return

    # child process
    cwd = os.getcwd()
    data.insert(0, cwd)
    if not os.path.exists(os.path.dirname(CACHE)):
        os.makedirs(os.path.dirname(CACHE))
    # Remove old cache
    if os.path.exists(CACHE):
        os.unlink(CACHE)
    pickle.dump(data, open(CACHE, "wb"))
    sys.exit(0)


def load():
    """
    Load and return data from the local cache.
    """
    try:
        return pickle.load(open(CACHE, "rb"))
    except (IOError, pickle.PickleError):
        return None


def print_contexts(slocs, indices, context_lines, args):
    """
    Prints context_lines lines before and after the matches given by
    the indices into the slocs array.
    """
    fdc = sys.stdout
    pop = None
    if args.noless is False:
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        pop = Popen("less -FRXS", shell=True, stdin=PIPE)
        fdc = pop.stdin

    for i in indices:
        sloc = rem_ansi(slocs[i])
        lfile, lline = parse_line(sloc)
        if lfile == -1 or lline == -1:
            continue
        with open(sloc[:lfile]) as fdc:
            line = int(sloc[lfile+1:lline])
            lines = fdc.readlines()
            start = max(1, line - context_lines)
            end = min(line + context_lines, len(lines)-1)
            width = len(str(end))
            delim = "%s %s %s %s" % (yel("-----"),
                                     yel(i, True),
                                     blu(sloc[:lfile], True),
                                     green("(%s-%s)" % (start, end)))
            fdc.write("%s %s\n" % (delim, yel("-" * (79-len(rem_ansi(delim))))))
            for j in range(start, end + 1):
                fdc.write(green('{0:>{1}}'.format(j, width), j == line) + " ")
                if j == line:
                    fdc.write(slocs[i][lline+1:])
                    fdc.write("\n")
                else:
                    fdc.write(lines[j-1])
    if pop:
        fdc.close()
        pop.wait()


if __name__ == "__main__":
    main()
